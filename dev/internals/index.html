<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · LAS.jl</title><meta name="title" content="Internals · LAS.jl"/><meta property="og:title" content="Internals · LAS.jl"/><meta property="twitter:title" content="Internals · LAS.jl"/><meta name="description" content="Documentation for LAS.jl."/><meta property="og:description" content="Documentation for LAS.jl."/><meta property="twitter:description" content="Documentation for LAS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LAS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../interface/">Interface</a></li><li><a class="tocitem" href="../header/">Header</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../vlrs/">Variable Length Records</a></li><li><a class="tocitem" href="../user_fields/">User Fields</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Data-Consistency"><span>Data Consistency</span></a></li><li><a class="tocitem" href="#Third-Party-Packages"><span>Third Party Packages</span></a></li><li><a class="tocitem" href="#Point-Records"><span>Point Records</span></a></li><li><a class="tocitem" href="#Reading-Points-Iterator"><span>Reading Points Iterator</span></a></li><li><a class="tocitem" href="#Writing-Optimisations"><span>Writing Optimisations</span></a></li><li><a class="tocitem" href="#Automatic-Support-for-User-Fields"><span>Automatic Support for User Fields</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fugro-oss/LAS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fugro-oss/LAS.jl/blob/main/docs/src/internals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><h2 id="Data-Consistency"><a class="docs-heading-anchor" href="#Data-Consistency">Data Consistency</a><a id="Data-Consistency-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Consistency" title="Permalink"></a></h2><p>When creating a <code>LasDataset</code> or writing a tabular point cloud out to a file, we need to make sure that the header information we provide is consistent with that of the point cloud and any <em>VLRs</em> and user bytes. Internally, this is done using the function <code>make_consistent_header!</code>, which compares a <code>LasHeader</code> and some <em>LAS</em> data and makes sure the header has the appropriate data offsets, flags and other metadata. This will, for example, make sure that the numbers of points, <em>VLRs</em> and <em>EVLRs</em> are consistent with the data we&#39;ve provided, so your <code>LasDataset</code> is guaranteed to be consistent.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.make_consistent_header!-internals" href="#LAS.make_consistent_header!-internals"><code>LAS.make_consistent_header!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_consistent_header!(
    header::LasHeader,
    pointcloud::AbstractVector{&lt;:NamedTuple},
    vlrs::Vector{&lt;:LasVariableLengthRecord},
    evlrs::Vector{&lt;:LasVariableLengthRecord},
    user_defined_bytes::Vector{UInt8}
) -&gt; UInt16
</code></pre><p>Ensure that a LAS <code>header</code> is consistent with a given <code>pointcloud</code> data coupled with sets of <code>vlrs</code>, <code>evlrs</code> and <code>user_defined_bytes</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/header.jl#L780-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.make_consistent_header-internals" href="#LAS.make_consistent_header-internals"><code>LAS.make_consistent_header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_consistent_header(
    pointcloud::AbstractVector{&lt;:NamedTuple},
    point_format::Type{TPoint&lt;:LasPoint},
    vlrs::Vector{&lt;:LasVariableLengthRecord},
    evlrs::Vector{&lt;:LasVariableLengthRecord},
    user_defined_bytes::Vector{UInt8},
    scale::Real
) -&gt; LasHeader
</code></pre><p>Construct a LAS header that is consistent with a given <code>pointcloud</code> data in a specific LAS <code>point_format</code>, coupled with sets of <code>vlrs</code>, <code>evlrs</code> and <code>user_defined_bytes</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/header.jl#L753-L757">source</a></section></article><h2 id="Third-Party-Packages"><a class="docs-heading-anchor" href="#Third-Party-Packages">Third Party Packages</a><a id="Third-Party-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Third-Party-Packages" title="Permalink"></a></h2><p>This package relies heavily upon <a href="https://github.com/EvertSchippers/PackedReadWrite.jl">PackedReadWrite.jl</a> to speed up the reading and writing of <code>LasPoint</code>s and some of our <em>VLRs</em>. </p><p>We also use <a href="https://github.com/JuliaIO/BufferedStreams.jl">BufferedStreams.jl</a> to drastically reduce I/O overhead.</p><h2 id="Point-Records"><a class="docs-heading-anchor" href="#Point-Records">Point Records</a><a id="Point-Records-1"></a><a class="docs-heading-anchor-permalink" href="#Point-Records" title="Permalink"></a></h2><p>As outlined in the <a href="../user_fields/">User Fields Section</a>, in order to offer full support of &quot;extra point data&quot; in our <em>LAS</em> files, we treat <em>LAS</em> point records as having a point, extra user fields and a set of undocumented bytes. Internally, however, this is broken up into 4 separate classes each implementing the <code>LasRecord</code> abstract type. These correspond to each combination of a point with/without user fields/undocumented bytes.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.LasRecord-internals" href="#LAS.LasRecord-internals"><code>LAS.LasRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LasRecord</code></pre><p>An abstract form of a LAS record. These are points with some additional information possibly included</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/records.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.PointRecord-internals" href="#LAS.PointRecord-internals"><code>LAS.PointRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PointRecord{TPoint} &lt;: LAS.LasRecord</code></pre><p>A LAS record that only has a point</p><ul><li><code>point::Any</code>: The LAS point stored in this record</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/records.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.ExtendedPointRecord-internals" href="#LAS.ExtendedPointRecord-internals"><code>LAS.ExtendedPointRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ExtendedPointRecord{TPoint, Names, Types} &lt;: LAS.LasRecord</code></pre><p>A LAS record that has a LAS point and extra user-defined point fields.  Note that these must be documented as <code>ExtraBytes</code> VLRs in the LAS file</p><ul><li><p><code>point::Any</code>: The LAS point stored in this record</p></li><li><p><code>user_fields::LAS.UserFields</code>: Extra user fields associated with this point</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/records.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.UndocPointRecord-internals" href="#LAS.UndocPointRecord-internals"><code>LAS.UndocPointRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct UndocPointRecord{TPoint, N} &lt;: LAS.LasRecord</code></pre><p>A LAS record that has a point as well as additional undocumented bytes (i.e. that don&#39;t have an associated <code>ExtraBytes</code> VLR)</p><ul><li><p><code>point::Any</code>: The LAS point stored in this record</p></li><li><p><code>undoc_bytes::StaticArraysCore.SVector{N, UInt8} where N</code>: Array of extra bytes after the point that haven&#39;t been documented in the VLRs</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/records.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.FullRecord-internals" href="#LAS.FullRecord-internals"><code>LAS.FullRecord</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FullRecord{TPoint, Names, Types, N} &lt;: LAS.LasRecord</code></pre><p>A LAS record that has a LAS point, extra user-defined fields and additional undocumented extra bytes</p><ul><li><p><code>point::Any</code>: The LAS point stored in this record</p></li><li><p><code>user_fields::LAS.UserFields</code>: Extra user fields associated with this point</p></li><li><p><code>undoc_bytes::StaticArraysCore.SVector{N, UInt8} where N</code>: Array of extra bytes after the point that haven&#39;t been documented in the VLRs</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/records.jl#L219-L225">source</a></section></article><p>This was done largely to increase performance of reading point records, since having one single type for point records would require more conditional checks to see if certain extra fields need to be read from a file which ends up congesting the read process. Instead, we use <em>Julia</em>&#39;s multiple dispatch and define <code>Base.read</code> and <code>Base.write</code> methods for each record type and avoid these checks and also decrease the type inference time when reading these into a vector.</p><h2 id="Reading-Points-Iterator"><a class="docs-heading-anchor" href="#Reading-Points-Iterator">Reading Points Iterator</a><a id="Reading-Points-Iterator-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-Points-Iterator" title="Permalink"></a></h2><p>When reading, we also wrap our IO stream in an iterator, <code>LAS.ReadPointsIterator</code>, to reduce the overhead of reading point records sequentially. It turns out that calling <code>map(r -&gt; r, iter)</code> where <code>iter</code> is a <code>LAS.ReadPointsIterator</code> is much faster than calling <code>map(_ -&gt; read(io, TRecord), 1:num_points)</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.ReadPointsIterator-internals" href="#LAS.ReadPointsIterator-internals"><code>LAS.ReadPointsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ReadPointsIterator{TIO, TRecord}</code></pre><p>An iterator for reading point records</p><ul><li><p><code>io::Any</code>: IO channel to read point records from</p></li><li><p><code>num_points::Integer</code>: Number of points to read in total</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/read.jl#L274-L280">source</a></section></article><h2 id="Writing-Optimisations"><a class="docs-heading-anchor" href="#Writing-Optimisations">Writing Optimisations</a><a id="Writing-Optimisations-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-Optimisations" title="Permalink"></a></h2><p>Typically, <em>Julia</em> is slower at performing multiple consecutive smaller writes to an IO channel than one much larger write. For this reason, when writing point records to a <em>LAS</em> file, we first construct a vector of bytes from the records and then write that whole vector to the file. This is possible since for each point record we know:</p><ul><li>How many bytes the point format is,</li><li>How many user fields in this record and their data size in bytes and</li><li>How many undocumented bytes there are.</li></ul><p>This is done using <code>LAS.get_record_bytes</code>, which takes a collection of <em>LAS</em> records and writes each <em>LAS</em> field, user field and extra bytes collection into its correct location in the final byte vector. </p><p>In order to do this, we need to frequently access each field in a (potentially huge) list of records, which in normal circumstances is slow. We instead first pass our records into a <code>StructVector</code> using <a href="https://github.com/JuliaArrays/StructArrays.jl">StructArrays.jl</a> which vastly increases the speed at which we can access these fields and broadcast over them.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LAS.get_record_bytes-internals" href="#LAS.get_record_bytes-internals"><code>LAS.get_record_bytes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_record_bytes(
    records::StructArrays.StructArray{TRecord&lt;:LAS.LasRecord, 1}
) -&gt; Any
</code></pre><p>Construct an array of bytes that correctly encodes the information stored in a set of LAS <code>records</code> according to the spec</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fugro-oss/LAS.jl/blob/6a54619820fbad44e4cd06de2d9bc3ee0b4415d8/src/write.jl#L141-L145">source</a></section></article><h2 id="Automatic-Support-for-User-Fields"><a class="docs-heading-anchor" href="#Automatic-Support-for-User-Fields">Automatic Support for User Fields</a><a id="Automatic-Support-for-User-Fields-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Support-for-User-Fields" title="Permalink"></a></h2><p>In order for the system to automatically handle a user supplying their own custom fields in a point cloud table, we make some checks on field types and have processes in place that ensure each column has an <code>ExtraBytes</code> <em>VLR</em> associated to it.</p><p>Firstly, the <em>LAS</em> 1.4 spec officially supports the following data types directly: <code>UInt8</code>, <code>Int8</code>, <code>UInt16</code>, <code>Int16</code>, <code>UInt32</code>, <code>Int32</code>, <code>UInt64</code>, <code>Int64</code>, <code>Float32</code> and <code>Float64</code></p><p>This means that every <code>ExtraBytes</code> <em>VLR</em> <strong>must</strong> have a data type among these values (note that vectors are not directly supported). <em>LAS.jl</em> supports static vectors (static sizing is essential) as user fields as well by internally separating out vector components and adding an <code>ExtraBytes</code> <em>VLR</em> for each component following the naming convention in the spec. That is, for a user field with <code>N</code> entries, the individual component names that are documented in the <em>VLRs</em> are &quot;col [0]&quot;, &quot;col [1]&quot;, ..., &quot;col [N - 1]&quot;.</p><p>When a user passes a custom field to the system, it will firstly check that the data type for this field is either one of the above types or an <code>SVector</code> of one. If it is a vector, it will construct a list of the component element field names as above. Then, it will extract all <code>ExtraBytes</code> <em>VLRs</em> and check if any of them have matching names and update them iff they exist so their data type matches the new type supplied. If these are new fields, a new <code>ExtraBytes</code> <em>VLR</em> will be added per field name. Finally, the header is updated to reflect the new number of <em>VLRs</em>, the new data offsets and the new point record lengths.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../user_fields/">« User Fields</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 5 June 2024 00:38">Wednesday 5 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
